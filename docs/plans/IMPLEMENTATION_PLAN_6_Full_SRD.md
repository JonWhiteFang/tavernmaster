# TavernMaster — Full D&D 5e SRD Content Ingestion (Comprehensive Implementation Plan)

**Objective:** Ship TavernMaster with **complete D&D 5e SRD content** that is legally available under **Creative Commons (CC-BY 4.0)**, and make it **importable, queryable, searchable, and usable** in the app (character creation, encounter building, AI SRD lookup, browsing).

This plan is written to be executed by **kiro-cli / codex-cli** as a sequence of small, reviewable PRs.

---

## 1) Ground truth & constraints

### 1.1 What “all available SRD” means

As of **2026-01-11**, “all available D&D 5e SRD content” reasonably means shipping both:

- **SRD 5.1 (2014 rules) — CC-BY 4.0**
- **SRD 5.2.1 (2024 rules update) — CC-BY 4.0**

Your app should support both simultaneously via **versioning** so users can choose a ruleset (per-campaign recommended).

### 1.2 Legal / attribution requirements (non-negotiable)

- Add required SRD attribution text to the repo and in-app “Licenses / About”.
- Ensure SRD content ingestion sources are traceable to the official SRD PDFs (or other CC-BY sources with explicit provenance).
- Do **not** ingest non-SRD content.

### 1.3 Current repo state (what we’re changing)

In the current codebase:

- SRD reference data lives in `src/assets/srd/srd.json` (currently tiny placeholder coverage).
- Import is performed by `src/app/data/srd.ts` via `importSrdIfNeeded()` and is **“import if table empty”**.
- SRD tables exist as many per-type tables in `src/app/data/schema.ts`:
  - `srd_spells`, `srd_items`, `srd_monsters`, `srd_conditions`, `srd_rules`, `srd_classes`, `srd_races`, `srd_backgrounds`
- Query surfaces:
  - `src/app/data/srd_queries.ts` (AI/tooling lookup)
  - `src/app/data/srdContent.ts` (character wizard lists for classes/races/backgrounds/items)

This plan replaces the ingestion model with a **versioned, upgrade-safe SRD sync**, and expands coverage to full SRD.

---

## 2) High-level solution

### 2.1 Store SRD as versioned “entries”

Instead of proliferating more and more `srd_*` tables (feats, magic items, glossary, etc.), store everything in a **single table**:

- `srd_entries` (versioned, typed)
- Optional `srd_entries_fts` for fast search
- `srd_meta` to track what dataset is imported (hash/version), enabling **upsert + delete-stale** sync

### 2.2 Ship SRD data as generated static assets (not bundled code)

Replace `src/assets/srd/srd.json` with a versioned asset layout:

```
src/assets/srd/
  manifest.json
  5.1/entries.json
  5.2.1/entries.json
```

These JSON files are generated by a script that:

- downloads official SRD PDFs,
- extracts/segments text,
- normalizes into a stable schema,
- emits deterministic IDs,
- writes a manifest with hashes for provenance.

### 2.3 Import behavior: “sync”, not “seed”

On startup:

- load `manifest.json`
- compute / read a dataset hash
- if hash differs from DB’s `srd_meta`, perform a **transactional sync**:
  - bulk upsert entries
  - delete stale entries per version
  - update `srd_meta`

---

## 3) Data contract (SRD entry schema)

### 3.1 Entry shape (stored in DB in `data_json`)

Use a small required envelope and allow per-type payloads.

**Required fields:**

- `id` — stable deterministic: `srd:{version}:{type}:{slug(name)}`
- `name` — display name
- `type` — e.g. `spell`, `monster`, `magic_item`, `feat`, `equipment`, `class`, `subclass`, `background`, `species`, `rule`, `glossary_term`, `condition`
- `srd_version` — `5.1` or `5.2.1`
- `data_json` — JSON payload, type-specific but consistent within a type
- `source_json` — provenance: pdf url/hash + page range + section label
- `search_text` — optional flattened text for FTS

### 3.2 Minimum type payload expectations

You can start “good enough to render + search” and deepen later.

- **Spell**: level, school, castingTime, range, components, duration, description, higherLevels
- **Monster/Animal**: size/type/alignment, AC, HP, speed, ability scores, saves/skills, senses/languages, CR, traits/actions/reactions/legendary, description
- **Magic item**: type, rarity, attunement, description
- **Feat**: category (e.g. origin/general), prerequisites, description
- **Class/Subclass**: hit die, primary ability, proficiencies, class features by level, spellcasting summary (if any)
- **Background**: proficiencies, equipment, feature text; (5.2.1 includes ability score choices + origin feat structure)
- **Species**: speed, traits; (5.2.1 differs from 5.1 race ability bonuses)
- **Equipment**: category, cost/weight, properties; weapons include mastery properties (5.2.1)
- **Rules / Glossary**: headings + text body + references

---

## 4) Database changes (SQLite)

### 4.1 Add new tables (keep old tables during transition)

Update `src/app/data/schema.ts` to include:

#### `srd_entries`

- `id TEXT PRIMARY KEY`
- `name TEXT NOT NULL`
- `type TEXT NOT NULL`
- `srd_version TEXT NOT NULL`
- `data_json TEXT NOT NULL`
- `search_text TEXT` (nullable)
- `source_json TEXT` (nullable)
- `created_at TEXT NOT NULL`
- `updated_at TEXT NOT NULL`

Indexes:

- `CREATE INDEX IF NOT EXISTS idx_srd_entries_version_type ON srd_entries(srd_version, type);`
- `CREATE INDEX IF NOT EXISTS idx_srd_entries_version_name ON srd_entries(srd_version, name);`

#### `srd_meta`

- `key TEXT PRIMARY KEY`
- `value TEXT NOT NULL`

Optional (recommended) full-text search (FTS5):

- `CREATE VIRTUAL TABLE IF NOT EXISTS srd_entries_fts USING fts5(name, search_text, content='srd_entries', content_rowid='rowid');`
- Add triggers to keep it in sync OR rebuild after import (simpler).

### 4.2 Migration strategy

- Do not drop existing `srd_*` tables in the first pass.
- Create `srd_entries` and update code to read from it.
- Once all reads are migrated, old tables can be removed in a later PR.

---

## 5) SRD asset pipeline (generator + manifest)

### 5.1 Add asset layout

Add:

- `src/assets/srd/manifest.json`
- `src/assets/srd/5.1/entries.json`
- `src/assets/srd/5.2.1/entries.json`

Manifest example:

```json
{
  "datasets": [
    {
      "version": "5.1",
      "sourcePdfUrl": "https://media.wizards.com/2023/downloads/dnd/SRD_CC_v5.1.pdf",
      "sourcePdfSha256": "…",
      "generatedAt": "2026-01-11T00:00:00Z",
      "entriesPath": "5.1/entries.json"
    },
    {
      "version": "5.2.1",
      "sourcePdfUrl": "https://media.dndbeyond.com/compendium-images/srd/5.2/SRD_CC_v5.2.1.pdf",
      "sourcePdfSha256": "…",
      "generatedAt": "2026-01-11T00:00:00Z",
      "entriesPath": "5.2.1/entries.json"
    }
  ]
}
```

### 5.2 Generator scripts

Create `scripts/srd/`:

- `download.ts` — downloads PDFs + computes sha256
- `extract.ts` — extracts page text (recommended: `pdfjs-dist`)
- `segment.ts` — segments per type/section (TOC + headings)
- `normalize.ts` — normalizes into TavernMaster SRD entry format
- `write.ts` — writes `entries.json` + updates manifest

Add npm scripts in `package.json`:

- `"srd:generate": "ts-node scripts/srd/generate.ts"`
- `"srd:verify": "ts-node scripts/srd/verify.ts"`

> Practical note: PDF segmentation is the hardest part. Start with “good enough” heuristics per section and improve iteratively; correctness is guarded by verification + counts + known-entry checks.

### 5.3 Segmentation heuristics (MVP)

Implement per-type segmenters:

- **Spells**: In “Spell Descriptions” section, split on headings matching spell names.
- **Monsters/Animals**: In “Monsters A–Z” / “Animals”, split on statblock headings.
- **Magic items**: In “Magic Items A–Z”, split on item headings.
- **Feats**: In “Feat Descriptions”, split on feat headings.
- **Glossary**: In “Rules Glossary”, split on term headings.
- **Classes/Subclasses/Backgrounds/Species/Equipment/Rules**: Use TOC anchors + headings.

Store page range and section name in `source_json` for traceability.

---

## 6) Import & sync (replace import-if-empty)

### 6.1 New import module

Create `src/app/data/srdSync.ts` (or refactor `src/app/data/srd.ts`) to expose:

- `syncSrdIfNeeded(): Promise<void>`
- `getSrdDatasetStatus(): Promise<{ manifestHash: string, importedHash?: string, versions: string[] }>`
- `setCampaignRulesetVersion(campaignId, version)` (later phase)

### 6.2 Sync algorithm

1. Load `src/assets/srd/manifest.json`.
2. Compute `manifestHash` (stable hash of manifest content).
3. Read DB meta: `SELECT value FROM srd_meta WHERE key='srd_manifest_hash'`.
4. If hash differs:
   - Begin transaction
   - For each dataset version in manifest:
     - Read `entries.json`
     - Bulk upsert into `srd_entries` by `id`
     - Track all IDs imported for that version
     - Delete stale rows for that version: `DELETE FROM srd_entries WHERE srd_version=? AND id NOT IN (…)` (chunk the IN list or use a temp table)
   - Update `srd_meta` keys:
     - `srd_manifest_hash`
     - `srd_last_imported_at`
   - Rebuild FTS (if using rebuild approach)
   - Commit

### 6.3 Performance considerations

- Batch inserts (e.g. 250–1000 rows per batch).
- Use prepared statements.
- If delete-stale via giant `NOT IN` is too large:
  - Create a temp table `srd_import_ids` for each version and join-delete.

### 6.4 Replace startup call sites

Find and replace uses of `importSrdIfNeeded()` with `syncSrdIfNeeded()`:

- likely called during app init (e.g. after `initDatabase()`).

Update tests:

- `src/app/data/srd.ingestion.test.ts` should become `srd.sync.test.ts` and test:
  - imports when meta hash differs
  - idempotent when hash is same
  - upsert updates changed entries
  - delete-stale removes removed entries
  - does not touch user data tables

---

## 7) Query layer refactor (read from `srd_entries`)

### 7.1 Replace `srd_queries.ts` (AI/tooling SRD lookup)

Refactor `src/app/data/srd_queries.ts` to query from `srd_entries`:

- Introduce types:
  - `SrdType` (string union)
  - `SrdVersion` (`"5.1" | "5.2.1"`)
- Update query contract:
  - `{ version, type, text, limit, filters… }`
- Implement simple filters:
  - spells: level, school
  - monsters: monsterType, CR range
  - items: category, rarity
  - feats: category
- Use FTS if available; otherwise fall back to `LIKE` on `name/search_text`.

Also update `querySrd` callers (`src/app/ai/orchestrator.ts`) to provide version.

### 7.2 Update `srdContent.ts` (character wizard lists)

Refactor `src/app/data/srdContent.ts` to read from `srd_entries`:

- `listSrdClasses(version)`
- `listSrdSpeciesOrRaces(version)`
- `listSrdBackgrounds(version)`
- `getSrdItemsByIds(version, ids)`

This is also where you’ll handle 5.1 vs 5.2.1 shape differences.

---

## 8) UI/UX deliverables (so users can see & trust the SRD coverage)

### 8.1 SRD Browser screen (MVP)

Add a new screen:

- Left: type list (Spells, Monsters, Animals, Magic Items, Feats, Equipment, Classes, Backgrounds, Species, Rules, Glossary)
- Top: search input + SRD version selector (5.1 / 5.2.1)
- Middle: list results
- Right: detail view rendering entry

Rendering:

- Start with plain text / basic formatting (paragraphs, headings).
- Later: improve statblock rendering for monsters/spells.

### 8.2 Ruleset selection (per campaign)

Add to `campaigns` table (via `ensureColumn` in `db.ts` or schema change):

- `ruleset_version TEXT NOT NULL DEFAULT '5.1'`

Expose in Campaign Settings:

- dropdown: `5.1 (2014)` / `5.2.1 (2024)`

Use this value as the default version for:

- character wizard
- encounter builder
- AI SRD lookup
- SRD browser (default filter)

---

## 9) Character creation compatibility (5.1 vs 5.2.1)

### 9.1 Update types

Current types are 5.1-centric (`SrdRace` includes ability bonuses).

Introduce versioned models:

- `SrdRace51` (ability bonuses + bonus choices)
- `SrdSpecies521` (traits; no ability bonuses by default)
- `SrdBackground51`
- `SrdBackground521` (ability score selections + origin feat data)
- `SrdFeat` (origin/general)

### 9.2 Wizard flow updates

For campaigns using 5.2.1:

- Add an **Origin Feat** step (or incorporate into Background selection if SRD structure supports it).
- Adjust ability score assignment logic (do not assume ancestry bonuses).

For campaigns using 5.1:

- Keep current flow as-is.

### 9.3 Store references not copies

Where possible store SRD IDs (e.g. `selected_background_id`) and resolve display text from `srd_entries`.

---

## 10) Completeness verification + CI guardrails

### 10.1 Verification script

Implement `scripts/srd/verify.ts` that checks:

- no duplicate `id`
- required fields exist on all entries
- per-version minimum counts for key categories (thresholds tuned once you generate real data)
- “known entries” exist (sanity list per version)
- optional: ensure `source_json` includes page ranges for traceability

### 10.2 CI integration

Add to pipeline (or local pre-commit):

- `npm test`
- `npm run srd:verify`

Fail builds if SRD dataset is missing or malformed.

---

## 11) PR-by-PR execution plan (Codex-friendly)

### PR 1 — Add licensing + attribution surfaces

**Files:**

- `NOTICE.md` (or `THIRD_PARTY_NOTICES.md`)
- Add “Licenses” UI route/screen

**Acceptance:**

- repo contains SRD attribution statements
- app shows them in About/Licenses

---

### PR 2 — Add `srd_entries` + `srd_meta` (+ optional FTS) tables

**Files:**

- `src/app/data/schema.ts`
- tests for schema creation (if present)

**Acceptance:**

- app boots and creates new tables
- no regressions in existing tests

---

### PR 3 — Add SRD manifest + generator skeleton

**Files:**

- `scripts/srd/*`
- `src/assets/srd/manifest.json` (initial stub)
- `package.json` scripts

**Acceptance:**

- `npm run srd:generate` downloads PDFs (or stub mode) and writes generated JSON
- manifest includes sha256 fields

---

### PR 4 — Generate & commit SRD 5.1 dataset

**Files:**

- `src/assets/srd/5.1/entries.json` (generated)
- update `manifest.json`

**Acceptance:**

- `npm run srd:verify` passes for 5.1
- local import path works

---

### PR 5 — Generate & commit SRD 5.2.1 dataset

**Files:**

- `src/assets/srd/5.2.1/entries.json` (generated)
- update `manifest.json`

**Acceptance:**

- `npm run srd:verify` passes for 5.2.1

---

### PR 6 — Implement `syncSrdIfNeeded()` and replace startup ingestion

**Files:**

- `src/app/data/srd.ts` (refactor) OR `src/app/data/srdSync.ts` (new)
- update startup init to call sync
- rewrite ingestion tests

**Acceptance:**

- first run imports all SRD entries into DB
- subsequent runs are no-op (hash match)
- changing assets updates DB without wiping user data

---

### PR 7 — Refactor `srd_queries.ts` and `srdContent.ts` to read from `srd_entries`

**Files:**

- `src/app/data/srd_queries.ts`
- `src/app/data/srdContent.ts`
- update callers/tests

**Acceptance:**

- AI SRD lookup works (at least spells/monsters)
- character wizard still lists content (at least 5.1 flow)

---

### PR 8 — SRD Browser UI + version selector

**Files:**

- New screen + routes
- data hooks calling the new query functions

**Acceptance:**

- user can browse all SRD types, search, and open details
- version switch works

---

### PR 9 — Per-campaign ruleset selection + 5.2.1-aware character wizard updates

**Files:**

- `campaigns` data model + UI
- character wizard types/flow

**Acceptance:**

- campaign selects 5.1 or 5.2.1
- wizard uses correct SRD version + flow adjustments

---

### PR 10 — Verification + CI guardrails

**Files:**

- `scripts/srd/verify.ts`
- CI config updates (if present)

**Acceptance:**

- CI fails if SRD data is missing/broken/regressed

---

## 12) Risks & mitigations

### PDF parsing correctness

**Risk:** headings/statblocks aren’t perfectly extractable.
**Mitigations:**

- store raw text block alongside parsed fields and render raw text if structured parsing fails
- keep `source_json` and a “needs_review” flag for edge cases
- use verification thresholds + known-entry checks to detect big breakages

### Dataset size & performance

**Risk:** slow import / slow search.
**Mitigations:**

- batch inserts, transactions
- indexes + FTS5
- consider lazy-loading details (list view uses name/type only)

### 5.1 vs 5.2.1 rules differences

**Risk:** character wizard assumptions break.
**Mitigations:**

- versioned SRD types
- per-campaign ruleset version
- keep 5.1 flow stable while incrementally adding 5.2.1 flow

---

## 13) Definition of done

- SRD assets include **complete SRD 5.1 + SRD 5.2.1** JSON datasets with provenance (pdf url + sha).
- App imports SRD via **sync/upsert/delete-stale** (no “wipe data” required).
- Users can **browse** SRD entries and **search** them.
- AI SRD lookup uses the same data.
- Character creation works for 5.1 and supports 5.2.1 with appropriate flow adjustments.
- Repo and app include required **CC-BY attribution**.

---
