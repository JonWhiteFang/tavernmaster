# Plan 03 — Player-first UX + AI Guardrails + Combat/Progression + Sync/Exports (Complete App)

## Goal

Deliver the complete product experience:

- One default **Play View** where the player only sees what they care about
- AI drives DMing, companions, enemies, bookkeeping, pacing
- Player controls only **1 party member**
- Campaign can resume after months with instant context
- Reliable AI structured outputs with schema validation, retries, and safe state application
- Combat, loot, and leveling playable end-to-end
- SRD complete and fast-searchable
- Backups/export/import and optional sync work securely
- Thorough tests (unit/integration/ui)

This plan assumes Plans 01–02 are complete.

---

## A. Structured AI turn format + guardrails (no freeform)

### A1) Replace current orchestrator with a Turn pipeline

Create new engine modules (do **not** bolt onto `PlayWorkspace`):

- `src/app/engine/ai/schemas.ts` (zod schemas)
- `src/app/engine/ai/playStyles.ts` (Cinematic/Tactical/Cozy/Grim/Fast)
- `src/app/engine/ai/promptBuilder.ts`
- `src/app/engine/ai/turnOrchestrator.ts`

**TurnResponse schema (required)**

- `mode: 'scene'|'combat'|'downtime'`
- `scene: { title: string; narrative: string; what_changed: string[] }`
- `choices: Array<{ id: string; label: string; intent: string; risk: 'low'|'medium'|'high' }>` (3–7)
- `player_prompt: string`
- `mechanics: { checks: Array<{ type: string; dc: number; why: string }>; rules_refs: string[] }` (hidden by default in UI)
- `state_patch: { campaign_state_patch: Partial<CampaignStateDoc>; combat_patch?: unknown }`
- `canon_updates: { facts_upsert: Array<{ key: string; fact_type: string; value_json: any; confidence: number }>; quests_upsert: Array<...>; npcs_upsert?: Array<...>; locations_upsert?: Array<...> }`
- `needs_clarification: boolean; clarifying_question: string|null`

### A2) Two-pass generation (Planner + Narrator)

To keep continuity reliable:

- Planner pass: temperature 0–0.3 → produces full TurnResponse
- Narrator pass: temperature based on play style → rewrites `scene.narrative` only, must preserve all other fields
- If narrator invalid → fall back to planner narrative

### A3) Deterministic validation and retries (NO semantic “repair”)

Update `src/app/ai/parser.ts` usage:

- Keep `extractJson()` helper.
- Stop using `parseJsonWithRepair()` in the main flow.

Retry strategy:

1. Try parse + validate.
2. If fails: retry once with **temperature=0**, stricter system prompt: “Return JSON only. No commentary.”
3. If still fails: show player a recovery banner and store raw output in Developer logs.

### A4) Transactional apply

Create:

- `src/app/engine/apply/applyTurn.ts`
- `src/app/engine/apply/validators.ts`

Apply order (single SQLite transaction):

1. Load current `CampaignStateDoc`
2. Validate patch against invariants (HP bounds, quest states, etc.)
3. Append Turn + snapshot (Plan 02)
4. Update `campaign_state.state_json` + summary columns
5. Upsert canon facts/quests
6. Update search index incrementally

If apply fails → rollback and re-ask planner with explicit validation errors.

---

## B. Player-first UI: Single “Play” view + progressive disclosure

### B1) Replace navigation hierarchy

Update `src/app/App.tsx`:

- Replace `PlayWorkspace` with new `PlayView`.
- Default nav shows only:
  - **Play**
  - **Campaign Library**
- Everything else moves under:
  - **Campaign Tools** (Map, Notes, Character, SRD) but hidden until a campaign is active
  - **Developer** (AI Director, Transcripts, Debug Encounter) only when Developer Mode enabled

Add `Developer Mode` toggle stored in `app_settings`.

### B2) Implement `PlayView.tsx`

Create: `src/app/screens/PlayView.tsx`

Default visible:

1. Current Scene (short)
2. Choices (3–7) + “Try something else…”
3. Your character status (HP/resources/conditions)
4. Collapsible timeline (“what just happened”)

Progressive disclosure:

- “Details” expander → mechanics, checks, rules refs
- “DM Notes” panel → canon updates summary (quests/NPCs)

Hotkeys:

- `1..7` pick choices
- `⌘Z` undo last turn
- `⌘⇧B` branch
- `⌘F` search timeline

### B3) Resume flow: “Last time on…” sheet

Update `src/app/screens/Dashboard.tsx`:

- “Continue Campaign” CTA
- On resume: show modal sheet generated by Plan 02 session lifecycle:
  - recap
  - active quests
  - key NPC relationships
  - current location
    Buttons:
- Start Session
- Jump In

---

## C. Combat integrated into play (AI runs everything except player intent)

### C1) Combat mode UI

In `PlayView`, when `state.mode==='combat'`:

- Show “My turn” and relevant actions.
- AI auto-resolves non-player turns with short narration.

### C2) Refactor EncounterFlow into developer-only debugger

Update `src/app/screens/EncounterFlow.tsx`:

- Keep it as a “Combat Debugger” behind Developer Mode.
- Main combat runs through turn pipeline + `CombatRunner`.

### C3) CombatRunner

Create: `src/app/engine/combat/CombatRunner.ts`

- Validates `combat_patch`
- Updates `CampaignStateDoc.activeEncounterId`
- Writes any detailed combat logs if you keep `combat_log`

Extend rules modules (`src/app/rules/*`) to support:

- attack, movement, opportunity attacks
- conditions
- death saves
- core SRD spell slot usage (bounded)

---

## D. Progression: loot, inventory, leveling

### D1) Inventory continuity

Ensure inventory is represented in `CampaignStateDoc` and reconciled with existing tables:

- Keep detailed `character_inventory` for storage.
- Generate a compact inventory summary into state doc for prompts and UI.

### D2) Leveling

Add a Level Up flow:

- AI proposes level up and a small set of choices.
- Player approves.
- Apply via state patch + updates to character tables.

---

## E. SRD completeness + fast search

### E1) SRD import audit

Audit `src/assets/srd/*` and `src/app/data/srdSync.ts`.
Ensure the SRD you intend to ship is fully represented in `srd_entries`.

### E2) SRD FTS

Add `srd_entries_fts` (FTS5) with triggers for insert/update.
Update `src/app/screens/SrdBrowser.tsx` to use FTS.

Add CI script: `scripts/verify_srd.ts` to assert expected types/counts exist.

---

## F. Export/import + backups as first-class (player confidence)

### F1) Campaign bundles

Create: `src/app/engine/importExport/bundles.ts`

- Export: campaign data + wrapped key material + metadata
- Import: validate schema/app version; restore safely; avoid id collisions

### F2) Scheduled backups

- Daily backup on first app launch that day
- Before branch/import

---

## G. Optional Sync (Supabase) that does not break encryption

### G1) Sync crypto meta

Ensure `crypto_meta` and wrapped key material sync.
On new device:

- require vault unlock (passphrase) before decrypting synced content.

### G2) Conflicts UI

Keep behind Developer Mode, but must be functional.

---

## H. Tests (thorough, required)

### Unit tests

- Turn schema validation
- Prompt builder canonicalization
- ApplyTurn invariants
- Combat state transitions
- SRD query correctness

### Integration tests

- 100-turn simulation with mocked LLM
- Undo/branch/retcon
- Export/import roundtrip with encryption

### UI tests

Use Playwright or equivalent for the PlayView:

- resume → recap sheet → pick option → see updated scene
- keyboard shortcuts
- accessibility smoke checks

### Security tests

- passphrase never written to disk
- no secrets in logs

---

## Acceptance criteria

- Player can run a campaign for hundreds of turns with stable continuity.
- Returning after weeks shows accurate recap + active threads.
- Player only controls one character; AI handles companions/enemies/bookkeeping.
- Combat, loot, and leveling work end-to-end.
- Export/import works and preserves encrypted logs with passphrase.
- Optional sync works without breaking decryptability.
- Test suites pass and are enforced by CI.
